# Fastfile for Submersion macOS App Store Automation
#
# Usage:
#   bundle exec fastlane screenshots        # Capture screenshots
#   bundle exec fastlane upload_screenshots # Upload screenshots to App Store Connect
#   bundle exec fastlane capture_and_upload # Both in one command
#
#   bundle exec fastlane build              # Build pkg for Mac App Store
#   bundle exec fastlane beta               # Build + upload to TestFlight
#   bundle exec fastlane release            # Build + upload to App Store
#   bundle exec fastlane full_release       # Screenshots + build + upload
#
#   Signing is handled automatically via Xcode + App Store Connect API key.

default_platform(:mac)

platform :mac do
  # ============================================================================
  # Helper Methods
  # ============================================================================

  def load_api_key
    if ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"] &&
       ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"] &&
       ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"]

      UI.message("Using API key from environment variables")
      return app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
        key_filepath: ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"],
        in_house: false
      )
    end

    json_path = "fastlane/api_key.json"
    if File.exist?(json_path)
      UI.message("Using API key from api_key.json")
      config = JSON.parse(File.read(json_path))
      return app_store_connect_api_key(
        key_id: config["key_id"],
        issuer_id: config["issuer_id"],
        key_filepath: config["key_filepath"],
        in_house: config["in_house"] || false
      )
    end

    UI.user_error!(
      "No API key found. Either set environment variables:\n" \
      "  APP_STORE_CONNECT_API_KEY_KEY_ID\n" \
      "  APP_STORE_CONNECT_API_KEY_ISSUER_ID\n" \
      "  APP_STORE_CONNECT_API_KEY_KEY_FILEPATH\n" \
      "Or create fastlane/api_key.json"
    )
  end

  # ============================================================================
  # Screenshot Lanes
  # ============================================================================

  desc "Capture Mac App Store screenshots via integration test"
  lane :screenshots do
    UI.message("Starting macOS screenshot capture...")

    screenshots_dir = File.absolute_path("../../screenshots")
    uddf_file = File.absolute_path("../../integration_test/fixtures/screenshot_test_data.uddf")

    # Generate UDDF test data
    generate_script = File.absolute_path("../../scripts/generate_uddf_test_data.py")
    if File.exist?(generate_script)
      sh("python3 '#{generate_script}' -o '#{uddf_file}'") rescue UI.message("Warning: Failed to generate UDDF test data")
    end

    # macOS sandbox remaps relative paths to ~/Library/Containers/<bundle-id>/Data/.
    # Stage the UDDF input into the sandbox container before the test, then copy
    # screenshots out of the container afterward.
    sandbox_data = File.join(Dir.home, "Library", "Containers", "app.submersion", "Data")
    sandbox_uddf_dir = File.join(sandbox_data, "integration_test", "fixtures")

    if File.exist?(uddf_file)
      FileUtils.mkdir_p(sandbox_uddf_dir)
      FileUtils.cp(uddf_file, sandbox_uddf_dir)
      UI.message("Staged UDDF test data into sandbox container")
    end

    sh("cd ../.. && flutter test integration_test/screenshots_test.dart " \
       "-d macos " \
       "--dart-define=SCREENSHOT_MODE=true " \
       "--dart-define=SCREENSHOT_DEVICE_NAME=macOS " \
       "--dart-define=SCREENSHOT_OUTPUT_DIR=screenshots " \
       "--dart-define=UDDF_TEST_DATA_PATH=integration_test/fixtures/screenshot_test_data.uddf")

    # Copy screenshots from sandbox container back to project directory
    sandbox_screenshots = File.join(sandbox_data, "screenshots", "macOS")
    if File.directory?(sandbox_screenshots)
      FileUtils.mkdir_p(File.join(screenshots_dir, "macOS"))
      FileUtils.cp(Dir.glob(File.join(sandbox_screenshots, "*.png")), File.join(screenshots_dir, "macOS"))
      UI.message("Copied macOS screenshots from sandbox container")
    end

    UI.success("macOS screenshots captured successfully!")
    UI.message("Screenshots saved to: #{screenshots_dir}/macOS/")
  end

  desc "Upload screenshots to Mac App Store Connect"
  lane :upload_screenshots do
    # macOS screenshots are in their own directory to avoid "Display Type Not Allowed!"
    # errors from mixing iOS and macOS resolutions in the same Fastlane screenshots path
    screenshots_path = File.absolute_path("../../screenshots/macos")

    unless File.directory?(screenshots_path)
      UI.user_error!("macOS screenshots directory not found at #{screenshots_path}. Run 'fastlane screenshots' first.")
    end

    # Resize screenshots to 2560x1600 (accepted macOS App Store size).
    # Captured screenshots are often 5120x3200 (native Retina 2x resolution).
    Dir.glob(File.join(screenshots_path, "**", "*.png")).each do |png|
      dimensions = `sips -g pixelWidth -g pixelHeight "#{png}" 2>/dev/null`
      width = dimensions[/pixelWidth:\s*(\d+)/, 1].to_i
      height = dimensions[/pixelHeight:\s*(\d+)/, 1].to_i
      if width > 2560 || height > 1600
        UI.message("Resizing #{File.basename(png)} from #{width}x#{height} to 2560x1600")
        sh("sips --resampleHeightWidth 1600 2560 \"#{png}\" >/dev/null 2>&1")
      end
    end

    api_key = load_api_key

    UI.message("Uploading macOS screenshots to App Store Connect...")

    upload_to_app_store(
      api_key: api_key,
      platform: 'osx',
      skip_binary_upload: true,
      skip_metadata: true,
      skip_app_version_update: true,
      screenshots_path: screenshots_path,
      overwrite_screenshots: true,
      ignore_language_directory_validation: true,
      precheck_include_in_app_purchases: false,
      force: true,
    )

    UI.success("macOS screenshots uploaded successfully!")
  end

  desc "Capture screenshots and upload to App Store Connect"
  lane :capture_and_upload do
    screenshots
    upload_screenshots
  end

  # ============================================================================
  # Build Lanes
  # ============================================================================

  desc "Build the macOS app for Mac App Store distribution"
  lane :build do
    api_key = load_api_key

    # Exclude auto_updater for App Store builds. The auto_updater plugin bundles
    # Sparkle.framework whose helper executables lack App Sandbox entitlements,
    # causing Apple to reject the upload. The Dart code already disables
    # auto-update for store channels via UPDATE_CHANNEL=appstore.
    flutter_plugins = File.absolute_path("../../.flutter-plugins")
    plugins_backup = File.exist?(flutter_plugins) ? File.read(flutter_plugins) : nil

    begin
      if plugins_backup
        filtered = plugins_backup.lines.reject { |l| l.start_with?("auto_updater=") }.join
        File.write(flutter_plugins, filtered)
        UI.message("Excluded auto_updater plugin for App Store build")
      end

      # Regenerate Flutter configs and plugin registrant (without auto_updater)
      UI.message("Building Flutter app...")
      sh("cd ../.. && flutter build macos --release --config-only --dart-define=UPDATE_CHANNEL=appstore")

      # Reinstall pods without auto_updater_macos / Sparkle
      # Clear Bundler env so system CocoaPods doesn't inherit fastlane's
      # Ruby 3.2 gem paths, which causes GemNotFound on CI runners
      Bundler.with_unbundled_env do
        sh("pod install")
      end

      UI.message("Building and signing pkg...")
      key_path = File.expand_path(
        ENV["APP_STORE_CONNECT_API_KEY_KEY_FILEPATH"],
        File.expand_path("..", __dir__)
      )
      auth_flags = "-allowProvisioningUpdates" \
        " -authenticationKeyPath '#{key_path}'" \
        " -authenticationKeyID '#{ENV["APP_STORE_CONNECT_API_KEY_KEY_ID"]}'" \
        " -authenticationKeyIssuerID '#{ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"]}'"

      build_mac_app(
        workspace: "Runner.xcworkspace",
        scheme: "Runner",
        export_method: "app-store",
        clean: true,
        output_directory: "./build",
        output_name: "Submersion",
        export_options: {
          signingStyle: "automatic",
          teamID: "8U3RSKF42Q",
          manageAppVersionAndBuildNumber: false
        },
        xcargs: auth_flags,
      )

      UI.success("Build complete! Pkg saved to macos/build/Submersion.pkg")
    ensure
      if plugins_backup
        File.write(flutter_plugins, plugins_backup)
        UI.message("Restored .flutter-plugins")
      end
    end
  end

  # ============================================================================
  # Upload Lanes
  # ============================================================================

  desc "Build and upload to TestFlight for beta testing"
  lane :beta do
    build

    api_key = load_api_key

    UI.message("Uploading to TestFlight...")
    upload_to_testflight(
      api_key: api_key,
      pkg: "./build/Submersion.pkg",
      skip_waiting_for_build_processing: true
    )

    UI.success("macOS build uploaded to TestFlight!")
  end

  desc "Build and upload to Mac App Store"
  lane :release do
    build

    api_key = load_api_key

    UI.message("Uploading to Mac App Store...")
    upload_to_app_store(
      api_key: api_key,
      pkg: "./build/Submersion.pkg",
      skip_screenshots: true,
      skip_metadata: true,
      submit_for_review: false,
      automatic_release: false,
      precheck_include_in_app_purchases: false
    )

    UI.success("macOS build uploaded to Mac App Store!")
  end

  desc "Full release: capture screenshots, upload everything, and submit build"
  lane :full_release do
    screenshots
    upload_screenshots
    release
  end

  # ============================================================================
  # Utility Lanes
  # ============================================================================

  desc "Clean up screenshot directories"
  lane :clean_screenshots do
    screenshots_path = "../../screenshots"

    if File.directory?(screenshots_path)
      FileUtils.rm_rf(screenshots_path)
      UI.success("Cleaned screenshots directory")
    else
      UI.message("No screenshots directory to clean")
    end
  end

  desc "Clean build artifacts"
  lane :clean do
    sh("cd ../.. && flutter clean")
    clear_derived_data

    build_path = "./build"
    if File.directory?(build_path)
      FileUtils.rm_rf(build_path)
      UI.message("Cleaned build directory")
    end

    UI.success("All build artifacts cleaned!")
  end

  desc "Show all available lanes"
  lane :lanes_help do
    UI.message("Available Fastlane lanes:")
    UI.message("")
    UI.message("  Screenshots:")
    UI.message("    screenshots        - Capture Mac App Store screenshots")
    UI.message("    upload_screenshots - Upload screenshots to App Store Connect")
    UI.message("    capture_and_upload - Both in one command")
    UI.message("")
    UI.message("  Build & Release:")
    UI.message("    build              - Build pkg for Mac App Store")
    UI.message("    beta               - Build + upload to TestFlight")
    UI.message("    release            - Build + upload to App Store")
    UI.message("    full_release       - Screenshots + build + upload")
    UI.message("")
    UI.message("  Utilities:")
    UI.message("    clean              - Clean all build artifacts")
    UI.message("    clean_screenshots  - Clean screenshot directory")
    UI.message("    lanes_help         - Show this help")
  end
end
