import 'dart:io';

import 'package:drift/drift.dart';
import 'package:submersion/core/database/database.dart';
import 'package:submersion/core/constants/enums.dart' as enums;
import 'package:submersion/core/services/export_service.dart';
import 'package:uuid/uuid.dart';

/// Imports UDDF test data into the database for App Store screenshots.
///
/// This helper reads a pre-generated UDDF file (from generate_uddf_test_data.py)
/// and imports the data directly into the test database. This provides more
/// consistent and realistic data than manually seeding.
class UddfScreenshotImporter {
  final AppDatabase db;
  final ExportService _exportService = ExportService();
  final _uuid = const Uuid();

  UddfScreenshotImporter(this.db);

  /// Imports all data from a UDDF file into the test database.
  ///
  /// The [uddfPath] should be an absolute path to the UDDF file generated by
  /// generate_uddf_test_data.py.
  Future<void> importFromFile(String uddfPath) async {
    final file = File(uddfPath);
    if (!file.existsSync()) {
      throw FileSystemException('UDDF file not found', uddfPath);
    }

    final uddfContent = await file.readAsString();
    await importFromContent(uddfContent);
  }

  /// Imports all data from UDDF content string into the test database.
  Future<void> importFromContent(String uddfContent) async {
    final importResult = await _exportService.importAllDataFromUddf(uddfContent);

    final now = DateTime.now();
    final nowMillis = now.millisecondsSinceEpoch;

    // Create diver first
    final diverId = _uuid.v4();
    await _createDiver(diverId, nowMillis);

    // Build ID mappings for cross-references
    final siteIdMapping = <String, String>{}; // UDDF site ID -> new site ID
    final buddyIdMapping = <String, String>{}; // UDDF buddy ID -> new buddy ID

    // Import dive sites
    for (final siteData in importResult.sites) {
      final siteName = siteData['name'] as String?;
      if (siteName == null || siteName.isEmpty) continue;

      final uddfId = siteData['uddfId'] as String?;
      final newId = _uuid.v4();

      await db.into(db.diveSites).insert(
            DiveSitesCompanion.insert(
              id: newId,
              diverId: Value(diverId),
              name: siteName,
              description: const Value(''),
              latitude: Value(siteData['latitude'] as double?),
              longitude: Value(siteData['longitude'] as double?),
              maxDepth: Value(siteData['maxDepth'] as double?),
              country: Value(siteData['country'] as String?),
              region: Value(siteData['region'] as String?),
              rating: Value(siteData['rating'] as double?),
              createdAt: nowMillis,
              updatedAt: nowMillis,
            ),
          );

      if (uddfId != null) {
        siteIdMapping[uddfId] = newId;
      }
    }

    // Import buddies
    for (final buddyData in importResult.buddies) {
      final buddyName = buddyData['name'] as String?;
      if (buddyName == null || buddyName.isEmpty) continue;

      final uddfId = buddyData['uddfId'] as String?;
      final newId = _uuid.v4();

      await db.into(db.buddies).insert(
            BuddiesCompanion.insert(
              id: newId,
              diverId: Value(diverId),
              name: buddyName,
              email: Value(buddyData['email'] as String?),
              phone: Value(buddyData['phone'] as String?),
              notes: Value(buddyData['notes'] as String? ?? ''),
              createdAt: nowMillis,
              updatedAt: nowMillis,
            ),
          );

      if (uddfId != null) {
        buddyIdMapping[uddfId] = newId;
      }
    }

    // Import equipment
    for (final equipData in importResult.equipment) {
      final equipName = equipData['name'] as String?;
      if (equipName == null || equipName.isEmpty) continue;

      final newId = _uuid.v4();

      // Parse equipment type to string for database
      String equipType = 'other';
      final typeValue = equipData['type'];
      if (typeValue is enums.EquipmentType) {
        equipType = typeValue.name;
      } else if (typeValue is String) {
        equipType = typeValue;
      }

      await db.into(db.equipment).insert(
            EquipmentCompanion.insert(
              id: newId,
              diverId: Value(diverId),
              name: equipName,
              type: equipType,
              brand: Value(equipData['brand'] as String?),
              model: Value(equipData['model'] as String?),
              serialNumber: Value(equipData['serialNumber'] as String?),
              notes: const Value(''),
              createdAt: nowMillis,
              updatedAt: nowMillis,
            ),
          );
    }

    // Import dives with profiles
    for (final diveData in importResult.dives) {
      final diveId = _uuid.v4();

      // Get linked site ID
      String? siteId;
      final linkedSiteId = diveData['siteId'] as String?;
      if (linkedSiteId != null) {
        siteId = siteIdMapping[linkedSiteId];
      }

      // Parse dive date
      int diveDateTime = nowMillis;
      final dateValue = diveData['dateTime'];
      if (dateValue is DateTime) {
        diveDateTime = dateValue.millisecondsSinceEpoch;
      } else if (dateValue is int) {
        diveDateTime = dateValue;
      }

      // Parse visibility to string
      String? visibility;
      final visValue = diveData['visibility'];
      if (visValue is enums.Visibility) {
        visibility = visValue.name;
      } else if (visValue is String) {
        visibility = visValue;
      }

      // Parse rating (may be double, convert to int)
      int? rating;
      final ratingValue = diveData['rating'];
      if (ratingValue is double) {
        rating = ratingValue.round();
      } else if (ratingValue is int) {
        rating = ratingValue;
      }

      await db.into(db.dives).insert(
            DivesCompanion.insert(
              id: diveId,
              diverId: Value(diverId),
              diveNumber: Value(diveData['diveNumber'] as int?),
              diveDateTime: diveDateTime,
              siteId: Value(siteId),
              maxDepth: Value(diveData['maxDepth'] as double?),
              avgDepth: Value(diveData['avgDepth'] as double?),
              duration: Value(diveData['duration'] as int?),
              visibility: Value(visibility),
              waterTemp: Value(diveData['waterTemp'] as double?),
              airTemp: Value(diveData['airTemp'] as double?),
              rating: Value(rating),
              notes: Value(diveData['notes'] as String? ?? ''),
              createdAt: nowMillis,
              updatedAt: nowMillis,
            ),
          );

      // Import dive profile points
      final profileData = diveData['profile'] as List<Map<String, dynamic>>?;
      if (profileData != null && profileData.isNotEmpty) {
        for (final point in profileData) {
          await db.into(db.diveProfiles).insert(
                DiveProfilesCompanion.insert(
                  id: _uuid.v4(),
                  diveId: diveId,
                  timestamp: point['timestamp'] as int? ?? 0,
                  depth: point['depth'] as double? ?? 0.0,
                  temperature: Value(point['temperature'] as double?),
                  pressure: Value(point['pressure'] as double?),
                ),
              );
        }
      }

      // Import dive tanks
      final tankData = diveData['tanks'] as List<Map<String, dynamic>>?;
      if (tankData != null && tankData.isNotEmpty) {
        for (final tank in tankData) {
          // Convert double pressures to int for database
          int? workingPressure;
          final wp = tank['workingPressure'];
          if (wp is double) {
            workingPressure = wp.round();
          } else if (wp is int) {
            workingPressure = wp;
          }

          int? startPressure;
          final sp = tank['startPressure'];
          if (sp is double) {
            startPressure = sp.round();
          } else if (sp is int) {
            startPressure = sp;
          }

          int? endPressure;
          final ep = tank['endPressure'];
          if (ep is double) {
            endPressure = ep.round();
          } else if (ep is int) {
            endPressure = ep;
          }

          await db.into(db.diveTanks).insert(
                DiveTanksCompanion.insert(
                  id: _uuid.v4(),
                  diveId: diveId,
                  volume: Value(tank['volume'] as double?),
                  workingPressure: Value(workingPressure),
                  startPressure: Value(startPressure),
                  endPressure: Value(endPressure),
                  o2Percent: Value(tank['o2Percent'] as double? ?? 21.0),
                  hePercent: Value(tank['hePercent'] as double? ?? 0.0),
                ),
              );
        }
      }
    }

    // Print summary
    // ignore: avoid_print
    print('UDDF Import complete:');
    // ignore: avoid_print
    print('   - Sites: ${importResult.sites.length}');
    // ignore: avoid_print
    print('   - Buddies: ${importResult.buddies.length}');
    // ignore: avoid_print
    print('   - Equipment: ${importResult.equipment.length}');
    // ignore: avoid_print
    print('   - Dives: ${importResult.dives.length}');
  }

  /// Creates a default diver profile for the test data.
  Future<void> _createDiver(String diverId, int now) async {
    await db.into(db.divers).insert(
          DiversCompanion.insert(
            id: diverId,
            name: 'Alex Rivera',
            email: const Value('alex.rivera@example.com'),
            phone: const Value('+1 555-DIVE'),
            bloodType: const Value('A+'),
            isDefault: const Value(true),
            createdAt: now,
            updatedAt: now,
          ),
        );
  }
}
