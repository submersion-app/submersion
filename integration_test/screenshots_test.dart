/// App Store Screenshot Automation Tests
///
/// This integration test captures screenshots of key app screens for
/// App Store submission. Run via the capture script:
///
/// ```bash
/// ./scripts/capture_screenshots.sh
/// # Or via fastlane:
/// cd ios && bundle exec fastlane screenshots
/// ```
///
/// Screenshots are saved to `screenshots/{device_name}/` directory.
/// The output path, device name, and UDDF test data path are passed via --dart-define.
library;

import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:submersion/app.dart';
import 'package:submersion/core/database/database.dart';
import 'package:submersion/core/providers/provider.dart';
import 'package:submersion/core/services/database_service.dart';
import 'package:submersion/features/buddies/data/repositories/buddy_repository.dart';
import 'package:submersion/features/certifications/data/repositories/certification_repository.dart';
import 'package:submersion/features/dive_centers/data/repositories/dive_center_repository.dart';
import 'package:submersion/features/dive_log/data/repositories/dive_repository_impl.dart';
import 'package:submersion/features/dive_log/data/repositories/tank_pressure_repository.dart';
import 'package:submersion/features/dive_sites/data/repositories/site_repository_impl.dart';
import 'package:submersion/features/dive_types/data/repositories/dive_type_repository.dart';
import 'package:submersion/features/divers/data/repositories/diver_repository.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_repository_impl.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_set_repository_impl.dart';
import 'package:submersion/features/settings/presentation/providers/settings_providers.dart';
import 'package:submersion/features/tags/data/repositories/tag_repository.dart';
import 'package:submersion/features/trips/data/repositories/trip_repository.dart';
import 'package:drift/native.dart';

import 'helpers/screenshot_helper.dart';
import 'helpers/screenshot_test_data.dart';
import 'helpers/uddf_screenshot_helper.dart';

/// Path to UDDF test data file, passed via --dart-define from capture script.
const String _kUddfTestDataPath = String.fromEnvironment(
  'UDDF_TEST_DATA_PATH',
  defaultValue: '',
);

/// Device orientation, passed via --dart-define from capture script.
/// Values: 'portrait' or 'landscape'
const String _kOrientation = String.fromEnvironment(
  'SCREENSHOT_ORIENTATION',
  defaultValue: 'portrait',
);

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  late AppDatabase testDb;
  late ScreenshotHelper screenshotHelper;
  late SharedPreferences prefs;

  setUpAll(() async {
    // Initialize SharedPreferences with empty values
    SharedPreferences.setMockInitialValues({});
    prefs = await SharedPreferences.getInstance();

    // Create in-memory database for testing
    testDb = AppDatabase(NativeDatabase.memory());
    DatabaseService.instance.setTestDatabase(testDb);

    // Seed with test data - prefer UDDF import for consistent data
    if (_kUddfTestDataPath.isNotEmpty &&
        File(_kUddfTestDataPath).existsSync()) {
      // Use UDDF test data generated by Python script for consistent screenshots
      // ignore: avoid_print
      print('Loading test data from UDDF: $_kUddfTestDataPath');

      // Create repositories - they use DatabaseService.instance.database which
      // is now our test database
      final importer = UddfScreenshotImporter(
        diverRepository: DiverRepository(),
        diveRepository: DiveRepository(),
        siteRepository: SiteRepository(),
        buddyRepository: BuddyRepository(),
        equipmentRepository: EquipmentRepository(),
        equipmentSetRepository: EquipmentSetRepository(),
        tripRepository: TripRepository(),
        diveCenterRepository: DiveCenterRepository(),
        certificationRepository: CertificationRepository(),
        tagRepository: TagRepository(),
        diveTypeRepository: DiveTypeRepository(),
        tankPressureRepository: TankPressureRepository(),
      );
      await importer.importFromFile(_kUddfTestDataPath);
    } else {
      // Fallback to manual seeder if UDDF file not available
      // ignore: avoid_print
      print('UDDF file not found, using manual test data seeder');
      final seeder = ScreenshotTestDataSeeder(testDb);
      await seeder.seedAll();
    }

    // Initialize screenshot helper
    // Device name and output dir are passed via --dart-define from capture script
    screenshotHelper = ScreenshotHelper(binding: binding);
  });

  tearDownAll(() async {
    await testDb.close();
    DatabaseService.instance.resetForTesting();
  });

  group('App Store Screenshots', () {
    testWidgets('Capture all screens', (WidgetTester tester) async {
      // Set device orientation based on --dart-define value
      // iPad screenshots are taken in landscape, iPhone in portrait
      if (_kOrientation == 'landscape') {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.landscapeLeft,
          DeviceOrientation.landscapeRight,
        ]);
      } else {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.portraitUp,
          DeviceOrientation.portraitDown,
        ]);
      }
      await tester.pumpAndSettle();

      // Launch the app with proper provider overrides
      await tester.pumpWidget(
        ProviderScope(
          overrides: [sharedPreferencesProvider.overrideWithValue(prefs)],
          child: const SubmersionApp(),
        ),
      );

      // Wait for initial load - app starts on /dashboard
      await tester.pumpAndSettle(const Duration(seconds: 3));
      await screenshotHelper.waitForContent(tester);

      // 1. Dashboard (initial screen)
      await screenshotHelper.takeScreenshot(tester, 'dashboard');

      // 2. Navigate to Dives - tap on scuba diving icon in bottom nav
      await _tapBottomNavItem(tester, Icons.scuba_diving_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'dive_list');

      // 3. Dive Detail - tap on a dive card
      // On iPad master-detail layout, there may be multiple ListViews (one in master,
      // one in detail summary). Find InkWells inside Cards which are the tappable areas.
      final random = Random();

      // Find all InkWells that are inside Cards (these are the tappable list items)
      final cardInkWells = find.descendant(
        of: find.byType(Card),
        matching: find.byType(InkWell),
      );

      // ignore: avoid_print
      print('Found ${cardInkWells.evaluate().length} InkWells in Cards');

      if (cardInkWells.evaluate().length > 3) {
        // Pick a random index, skipping first few which might be summary cards
        final maxIndex = min(cardInkWells.evaluate().length - 1, 10);
        final randomIndex = 2 + random.nextInt(max(1, maxIndex - 2));
        // ignore: avoid_print
        print(
          'Selecting InkWell at index $randomIndex of ${cardInkWells.evaluate().length}',
        );

        await tester.tap(cardInkWells.at(randomIndex));
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );

        // Verify we're on a dive detail page by looking for dive-specific content.
        // The detail pane should now show dive profile toggles or depth info.
        final pressureToggle = find.text('Pressure');
        final depthLabel = find.textContaining('Max Depth');

        // Check for dive-specific elements (profile chart toggles or depth info)
        final hasDiveContent =
            pressureToggle.evaluate().isNotEmpty ||
            depthLabel.evaluate().isNotEmpty;

        if (hasDiveContent) {
          // Enable Pressure and SAC toggles in the dive profile chart
          await _enableProfileToggles(tester);
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'dive_detail');
        } else {
          // Selection may not have worked - log warning
          // ignore: avoid_print
          print(
            'WARNING: Did not find dive content after tap, detail pane may not have updated',
          );
          // Still take a screenshot to see what's shown
          await screenshotHelper.takeScreenshot(tester, 'dive_detail');
        }

        // Go back to dive list (on mobile) or clear selection (on tablet)
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton.first);
          await tester.pumpAndSettle();
        }
      }

      // 4. Navigate to Sites
      await _tapBottomNavItem(tester, Icons.location_on_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'sites_list');

      // 5. Sites Map view - find the map button with tooltip 'Map View'
      // On iPad master-detail layout, there may be multiple icons, so use tooltip
      final mapViewButton = find.byTooltip('Map View');
      bool navigatedToMap = false;

      if (mapViewButton.evaluate().isNotEmpty) {
        // ignore: avoid_print
        print('Found Map View button, tapping...');
        await tester.tap(mapViewButton.first);
        await tester.pumpAndSettle();

        // Wait for navigation
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );

        // Verify we're on the map page by looking for map-specific elements
        // The SiteMapPage has title "Dive Sites Map" and a "List View" button
        final mapPageTitle = find.text('Dive Sites Map');
        final listViewButton = find.byTooltip('List View');

        navigatedToMap =
            mapPageTitle.evaluate().isNotEmpty ||
            listViewButton.evaluate().isNotEmpty;

        // ignore: avoid_print
        print('Navigation to map successful: $navigatedToMap');
      } else {
        // Fallback: try finding by icon
        final mapButton = find.byIcon(Icons.map);
        if (mapButton.evaluate().isNotEmpty) {
          await tester.tap(mapButton.first);
          await tester.pumpAndSettle();
          await screenshotHelper.waitForContent(
            tester,
            duration: const Duration(seconds: 2),
          );

          final mapPageTitle = find.text('Dive Sites Map');
          navigatedToMap = mapPageTitle.evaluate().isNotEmpty;
        }
      }

      if (navigatedToMap) {
        // Tap "Fit All Sites" button to center the map on all dive site markers
        final fitAllSitesButton = find.byTooltip('Fit All Sites');
        if (fitAllSitesButton.evaluate().isNotEmpty) {
          await tester.tap(fitAllSitesButton.first);
          await tester.pumpAndSettle();
        } else {
          // Try finding by icon as fallback
          final myLocationIcon = find.byIcon(Icons.my_location);
          if (myLocationIcon.evaluate().isNotEmpty) {
            await tester.tap(myLocationIcon.first);
            await tester.pumpAndSettle();
          }
        }

        // Wait for map tiles to render after zoom/pan animation
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 4),
        );
        await screenshotHelper.takeScreenshot(tester, 'sites_map');

        // Navigate back to sites list for next steps
        final listButton = find.byTooltip('List View');
        if (listButton.evaluate().isNotEmpty) {
          await tester.tap(listButton.first);
          await tester.pumpAndSettle();
        } else {
          final backButton = find.byTooltip('Back');
          if (backButton.evaluate().isNotEmpty) {
            await tester.tap(backButton.first);
            await tester.pumpAndSettle();
          }
        }
      } else {
        // ignore: avoid_print
        print('WARNING: Could not navigate to map view');
      }

      // 6. Navigate to Equipment via "More" menu
      await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
      await tester.pumpAndSettle();

      // Find and tap Equipment in the menu/list
      final equipmentText = find.text('Equipment');
      if (equipmentText.evaluate().isNotEmpty) {
        await tester.tap(equipmentText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);

        // On iPad, select an equipment item to show its details in the right pane
        // Find the ListView containing equipment cards
        final equipmentListView = find.byType(ListView);
        if (equipmentListView.evaluate().isNotEmpty) {
          final equipmentCards = find.descendant(
            of: equipmentListView.first,
            matching: find.byType(Card),
          );

          // ignore: avoid_print
          print(
            'Found ${equipmentCards.evaluate().length} cards in equipment ListView',
          );

          if (equipmentCards.evaluate().length > 1) {
            // Tap on the second equipment card (skip first in case it's a header)
            final cardIndex = min(2, equipmentCards.evaluate().length - 1);
            await tester.tap(equipmentCards.at(cardIndex));
            await tester.pumpAndSettle();
            await screenshotHelper.waitForContent(
              tester,
              duration: const Duration(seconds: 1),
            );
          }
        }

        await screenshotHelper.takeScreenshot(tester, 'equipment');
      }

      // 7. Navigate to Statistics via "More" menu
      await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
      await tester.pumpAndSettle();

      final statisticsText = find.text('Statistics');
      if (statisticsText.evaluate().isNotEmpty) {
        await tester.tap(statisticsText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        ); // Charts need time
        await screenshotHelper.takeScreenshot(tester, 'statistics');
      }

      // 8. Navigate to Records
      // First check if Records is directly accessible or under Statistics
      final recordsText = find.text('Records');
      if (recordsText.evaluate().isNotEmpty) {
        await tester.tap(recordsText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'records');
      } else {
        // Try via More menu
        await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
        await tester.pumpAndSettle();
        final recordsInMore = find.text('Records');
        if (recordsInMore.evaluate().isNotEmpty) {
          await tester.tap(recordsInMore.first);
          await tester.pumpAndSettle();
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'records');
        }
      }
    });
  });
}

/// Enables Pressure and SAC toggles in the dive profile chart.
/// These toggles show additional data curves on the profile graph.
Future<void> _enableProfileToggles(WidgetTester tester) async {
  // The toggles are text labels that can be tapped
  // Look for Pressure toggle and tap it if found
  final pressureToggle = find.text('Pressure');
  if (pressureToggle.evaluate().isNotEmpty) {
    await tester.tap(pressureToggle.first);
    await tester.pumpAndSettle();
  }

  // Look for SAC toggle and tap it if found
  final sacToggle = find.text('SAC');
  if (sacToggle.evaluate().isNotEmpty) {
    await tester.tap(sacToggle.first);
    await tester.pumpAndSettle();
  }
}

/// Taps a bottom navigation item by its icon.
Future<void> _tapBottomNavItem(WidgetTester tester, IconData icon) async {
  // Try to find the icon in the bottom navigation
  final iconFinder = find.byIcon(icon);
  if (iconFinder.evaluate().isNotEmpty) {
    await tester.tap(iconFinder.first);
    await tester.pumpAndSettle();
  } else {
    // Try the selected version of the icon (some icons change when selected)
    final selectedIcon = _getSelectedIcon(icon);
    if (selectedIcon != null) {
      final selectedIconFinder = find.byIcon(selectedIcon);
      if (selectedIconFinder.evaluate().isNotEmpty) {
        await tester.tap(selectedIconFinder.first);
        await tester.pumpAndSettle();
      }
    }
  }
}

/// Gets the selected variant of an outlined icon.
IconData? _getSelectedIcon(IconData outlinedIcon) {
  if (outlinedIcon == Icons.home_outlined) return Icons.home;
  if (outlinedIcon == Icons.scuba_diving_outlined) return Icons.scuba_diving;
  if (outlinedIcon == Icons.location_on_outlined) return Icons.location_on;
  if (outlinedIcon == Icons.flight_outlined) return Icons.flight;
  if (outlinedIcon == Icons.more_horiz_outlined) return Icons.more_horiz;
  return null;
}
