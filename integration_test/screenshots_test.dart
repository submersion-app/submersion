/// App Store Screenshot Automation Tests
///
/// This integration test captures screenshots of key app screens for
/// App Store submission. Run via the capture script:
///
/// ```bash
/// ./scripts/capture_screenshots.sh
/// # Or via fastlane:
/// cd ios && bundle exec fastlane screenshots
/// ```
///
/// Screenshots are saved to `screenshots/{device_name}/` directory.
/// The output path, device name, and UDDF test data path are passed via --dart-define.
library;

import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:submersion/app.dart';
import 'package:submersion/core/database/database.dart';
import 'package:submersion/core/providers/provider.dart';
import 'package:submersion/core/services/database_service.dart';
import 'package:submersion/features/buddies/data/repositories/buddy_repository.dart';
import 'package:submersion/features/certifications/data/repositories/certification_repository.dart';
import 'package:submersion/features/dive_centers/data/repositories/dive_center_repository.dart';
import 'package:submersion/features/dive_log/data/repositories/dive_repository_impl.dart';
import 'package:submersion/features/dive_log/data/repositories/tank_pressure_repository.dart';
import 'package:submersion/features/dive_sites/data/repositories/site_repository_impl.dart';
import 'package:submersion/features/dive_types/data/repositories/dive_type_repository.dart';
import 'package:submersion/features/divers/data/repositories/diver_repository.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_repository_impl.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_set_repository_impl.dart';
import 'package:submersion/features/settings/presentation/providers/settings_providers.dart';
import 'package:submersion/features/tags/data/repositories/tag_repository.dart';
import 'package:submersion/features/trips/data/repositories/trip_repository.dart';
import 'package:drift/native.dart';

import 'helpers/screenshot_helper.dart';
import 'helpers/screenshot_test_data.dart';
import 'helpers/uddf_screenshot_helper.dart';

/// Path to UDDF test data file, passed via --dart-define from capture script.
const String _kUddfTestDataPath = String.fromEnvironment(
  'UDDF_TEST_DATA_PATH',
  defaultValue: '',
);

/// Device orientation, passed via --dart-define from capture script.
/// Values: 'portrait' or 'landscape'
const String _kOrientation = String.fromEnvironment(
  'SCREENSHOT_ORIENTATION',
  defaultValue: 'portrait',
);

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  late AppDatabase testDb;
  late ScreenshotHelper screenshotHelper;
  late SharedPreferences prefs;

  setUpAll(() async {
    // Initialize SharedPreferences with empty values
    SharedPreferences.setMockInitialValues({});
    prefs = await SharedPreferences.getInstance();

    // Create in-memory database for testing
    testDb = AppDatabase(NativeDatabase.memory());
    DatabaseService.instance.setTestDatabase(testDb);

    // Seed with test data - prefer UDDF import for consistent data
    if (_kUddfTestDataPath.isNotEmpty &&
        File(_kUddfTestDataPath).existsSync()) {
      // Use UDDF test data generated by Python script for consistent screenshots
      // ignore: avoid_print
      print('Loading test data from UDDF: $_kUddfTestDataPath');

      // Create repositories - they use DatabaseService.instance.database which
      // is now our test database
      final importer = UddfScreenshotImporter(
        diverRepository: DiverRepository(),
        diveRepository: DiveRepository(),
        siteRepository: SiteRepository(),
        buddyRepository: BuddyRepository(),
        equipmentRepository: EquipmentRepository(),
        equipmentSetRepository: EquipmentSetRepository(),
        tripRepository: TripRepository(),
        diveCenterRepository: DiveCenterRepository(),
        certificationRepository: CertificationRepository(),
        tagRepository: TagRepository(),
        diveTypeRepository: DiveTypeRepository(),
        tankPressureRepository: TankPressureRepository(),
      );
      await importer.importFromFile(_kUddfTestDataPath);
    } else {
      // Fallback to manual seeder if UDDF file not available
      // ignore: avoid_print
      print('UDDF file not found, using manual test data seeder');
      final seeder = ScreenshotTestDataSeeder(testDb);
      await seeder.seedAll();
    }

    // Initialize screenshot helper
    // Device name and output dir are passed via --dart-define from capture script
    screenshotHelper = ScreenshotHelper(binding: binding);
  });

  tearDownAll(() async {
    await testDb.close();
    DatabaseService.instance.resetForTesting();
  });

  group('App Store Screenshots', () {
    testWidgets('Capture all screens', (WidgetTester tester) async {
      // Set device orientation based on --dart-define value
      // iPad screenshots are taken in landscape, iPhone in portrait
      if (_kOrientation == 'landscape') {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.landscapeLeft,
          DeviceOrientation.landscapeRight,
        ]);
      } else {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.portraitUp,
          DeviceOrientation.portraitDown,
        ]);
      }
      await tester.pumpAndSettle();

      // Launch the app with proper provider overrides
      await tester.pumpWidget(
        ProviderScope(
          overrides: [sharedPreferencesProvider.overrideWithValue(prefs)],
          child: const SubmersionApp(),
        ),
      );

      // Wait for initial load - app starts on /dashboard
      await tester.pumpAndSettle(const Duration(seconds: 3));
      await screenshotHelper.waitForContent(tester);

      // 1. Dashboard (initial screen)
      await screenshotHelper.takeScreenshot(tester, 'dashboard');

      // 2. Navigate to Dives - tap on scuba diving icon in bottom nav
      await _tapBottomNavItem(tester, Icons.scuba_diving_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'dive_list');

      // 3. Dive Detail - tap on a dive card
      // Find cards that are dive items by looking for cards containing dive-specific
      // content (scuba diving icon indicates a dive card vs site card with location icon)
      final random = Random();

      // Look for cards within the dive list - they should have scuba_diving icons
      // as leading icons (vs location_on icons for site cards)
      final diveCards = find.byWidgetPredicate((widget) {
        if (widget is Card) {
          // Check if this card is a descendant of a widget tree that contains
          // dive-related content (we'll tap it and verify after)
          return true;
        }
        return false;
      });

      if (diveCards.evaluate().length > 2) {
        // Pick a random card index (avoiding first which might be a header card)
        final maxIndex = min(diveCards.evaluate().length - 1, 10);
        final randomIndex = 1 + random.nextInt(maxIndex);
        // ignore: avoid_print
        print(
          'Selecting dive card at index $randomIndex of ${diveCards.evaluate().length} cards',
        );

        await tester.tap(diveCards.at(randomIndex));
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );

        // Verify we're on a dive detail page by looking for dive-specific content.
        // If we accidentally tapped a site, navigate back.
        final pressureToggle = find.text('Pressure');
        final depthLabel = find.textContaining('Max Depth');

        // Check for dive-specific elements (profile chart toggles or depth info)
        final hasDiveContent = pressureToggle.evaluate().isNotEmpty ||
            depthLabel.evaluate().isNotEmpty;

        if (hasDiveContent) {
          // Enable Pressure and SAC toggles in the dive profile chart
          await _enableProfileToggles(tester);
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'dive_detail');
        } else {
          // We might have tapped a site card - go back and try again
          // ignore: avoid_print
          print('WARNING: Did not find dive content, may have tapped wrong card');
          final backButton = find.byTooltip('Back');
          if (backButton.evaluate().isNotEmpty) {
            await tester.tap(backButton.first);
            await tester.pumpAndSettle();
          }
        }

        // Go back to dive list (on mobile) or clear selection (on tablet)
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton.first);
          await tester.pumpAndSettle();
        }
      }

      // 4. Navigate to Sites
      await _tapBottomNavItem(tester, Icons.location_on_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'sites_list');

      // 5. Sites Map view - look for map icon button in app bar
      final mapButton = find.byIcon(Icons.map);
      final mapOutlinedButton = find.byIcon(Icons.map_outlined);
      bool navigatedToMap = false;

      if (mapButton.evaluate().isNotEmpty) {
        await tester.tap(mapButton.first);
        await tester.pumpAndSettle();
        navigatedToMap = true;
      } else if (mapOutlinedButton.evaluate().isNotEmpty) {
        await tester.tap(mapOutlinedButton.first);
        await tester.pumpAndSettle();
        navigatedToMap = true;
      }

      if (navigatedToMap) {
        // Wait for map page to load
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );

        // Tap "Fit All Sites" button to center the map on all dive site markers
        // This button has tooltip 'Fit All Sites' and icon Icons.my_location
        final fitAllSitesButton = find.byTooltip('Fit All Sites');
        if (fitAllSitesButton.evaluate().isNotEmpty) {
          await tester.tap(fitAllSitesButton.first);
          await tester.pumpAndSettle();
        } else {
          // Try finding by icon as fallback
          final myLocationIcon = find.byIcon(Icons.my_location);
          if (myLocationIcon.evaluate().isNotEmpty) {
            await tester.tap(myLocationIcon.first);
            await tester.pumpAndSettle();
          }
        }

        // Wait for map tiles to render after zoom/pan animation
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 4),
        );
        await screenshotHelper.takeScreenshot(tester, 'sites_map');

        // Navigate back to sites list for next steps
        final listButton = find.byIcon(Icons.list);
        if (listButton.evaluate().isNotEmpty) {
          await tester.tap(listButton.first);
          await tester.pumpAndSettle();
        } else {
          final backButton = find.byTooltip('Back');
          if (backButton.evaluate().isNotEmpty) {
            await tester.tap(backButton.first);
            await tester.pumpAndSettle();
          }
        }
      }

      // 6. Navigate to Equipment via "More" menu
      await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
      await tester.pumpAndSettle();

      // Find and tap Equipment in the menu/list
      final equipmentText = find.text('Equipment');
      if (equipmentText.evaluate().isNotEmpty) {
        await tester.tap(equipmentText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'equipment');
      }

      // 7. Navigate to Statistics via "More" menu
      await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
      await tester.pumpAndSettle();

      final statisticsText = find.text('Statistics');
      if (statisticsText.evaluate().isNotEmpty) {
        await tester.tap(statisticsText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        ); // Charts need time
        await screenshotHelper.takeScreenshot(tester, 'statistics');
      }

      // 8. Navigate to Records
      // First check if Records is directly accessible or under Statistics
      final recordsText = find.text('Records');
      if (recordsText.evaluate().isNotEmpty) {
        await tester.tap(recordsText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'records');
      } else {
        // Try via More menu
        await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
        await tester.pumpAndSettle();
        final recordsInMore = find.text('Records');
        if (recordsInMore.evaluate().isNotEmpty) {
          await tester.tap(recordsInMore.first);
          await tester.pumpAndSettle();
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'records');
        }
      }
    });
  });
}

/// Enables Pressure and SAC toggles in the dive profile chart.
/// These toggles show additional data curves on the profile graph.
Future<void> _enableProfileToggles(WidgetTester tester) async {
  // The toggles are text labels that can be tapped
  // Look for Pressure toggle and tap it if found
  final pressureToggle = find.text('Pressure');
  if (pressureToggle.evaluate().isNotEmpty) {
    await tester.tap(pressureToggle.first);
    await tester.pumpAndSettle();
  }

  // Look for SAC toggle and tap it if found
  final sacToggle = find.text('SAC');
  if (sacToggle.evaluate().isNotEmpty) {
    await tester.tap(sacToggle.first);
    await tester.pumpAndSettle();
  }
}

/// Taps a bottom navigation item by its icon.
Future<void> _tapBottomNavItem(WidgetTester tester, IconData icon) async {
  // Try to find the icon in the bottom navigation
  final iconFinder = find.byIcon(icon);
  if (iconFinder.evaluate().isNotEmpty) {
    await tester.tap(iconFinder.first);
    await tester.pumpAndSettle();
  } else {
    // Try the selected version of the icon (some icons change when selected)
    final selectedIcon = _getSelectedIcon(icon);
    if (selectedIcon != null) {
      final selectedIconFinder = find.byIcon(selectedIcon);
      if (selectedIconFinder.evaluate().isNotEmpty) {
        await tester.tap(selectedIconFinder.first);
        await tester.pumpAndSettle();
      }
    }
  }
}

/// Gets the selected variant of an outlined icon.
IconData? _getSelectedIcon(IconData outlinedIcon) {
  if (outlinedIcon == Icons.home_outlined) return Icons.home;
  if (outlinedIcon == Icons.scuba_diving_outlined) return Icons.scuba_diving;
  if (outlinedIcon == Icons.location_on_outlined) return Icons.location_on;
  if (outlinedIcon == Icons.flight_outlined) return Icons.flight;
  if (outlinedIcon == Icons.more_horiz_outlined) return Icons.more_horiz;
  return null;
}
