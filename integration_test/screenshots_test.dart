/// App Store Screenshot Automation Tests
///
/// This integration test captures screenshots of key app screens for
/// App Store submission. Run via the capture script:
///
/// ```bash
/// ./scripts/release/capture_screenshots.sh
/// # Or via fastlane:
/// cd ios && bundle exec fastlane screenshots
/// ```
///
/// Screenshots are saved to `screenshots/{device_name}/` directory.
/// The output path, device name, and UDDF test data path are passed via --dart-define.
library;

import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:submersion/app.dart';
import 'package:submersion/core/database/database.dart';
import 'package:submersion/core/providers/provider.dart';
import 'package:submersion/core/services/database_service.dart';
import 'package:submersion/features/buddies/data/repositories/buddy_repository.dart';
import 'package:submersion/features/certifications/data/repositories/certification_repository.dart';
import 'package:submersion/features/dive_centers/data/repositories/dive_center_repository.dart';
import 'package:submersion/features/dive_log/data/repositories/dive_repository_impl.dart';
import 'package:submersion/features/dive_log/data/repositories/tank_pressure_repository.dart';
import 'package:submersion/features/dive_sites/data/repositories/site_repository_impl.dart';
import 'package:submersion/features/dive_types/data/repositories/dive_type_repository.dart';
import 'package:submersion/features/divers/data/repositories/diver_repository.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_repository_impl.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_set_repository_impl.dart';
import 'package:submersion/features/settings/presentation/providers/settings_providers.dart';
import 'package:submersion/features/tags/data/repositories/tag_repository.dart';
import 'package:submersion/features/trips/data/repositories/trip_repository.dart';
import 'package:submersion/features/dive_log/presentation/pages/dive_list_page.dart';
import 'package:drift/native.dart';
import 'package:flutter_map/flutter_map.dart';

import 'helpers/screenshot_helper.dart';
import 'helpers/screenshot_test_data.dart';
import 'helpers/uddf_screenshot_helper.dart';

/// Path to UDDF test data file, passed via --dart-define from capture script.
const String _kUddfTestDataPath = String.fromEnvironment(
  'UDDF_TEST_DATA_PATH',
  defaultValue: '',
);

/// Device orientation, passed via --dart-define from capture script.
/// Values: 'portrait' or 'landscape'
const String _kOrientation = String.fromEnvironment(
  'SCREENSHOT_ORIENTATION',
  defaultValue: 'portrait',
);

/// Whether we are running on a desktop platform (macOS, Windows, Linux).
bool get _isDesktop =>
    Platform.isMacOS || Platform.isWindows || Platform.isLinux;

/// Pumps multiple frames to allow layout and navigation transitions to
/// complete, without waiting for all animations to stop. This avoids hangs
/// caused by infinite/repeating animations (e.g. the HeroHeader ocean effect).
Future<void> _settle(WidgetTester tester, {int frames = 10}) async {
  for (int i = 0; i < frames; i++) {
    await tester.pump(const Duration(milliseconds: 100));
  }
}

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  late AppDatabase testDb;
  late ScreenshotHelper screenshotHelper;
  late SharedPreferences prefs;

  setUpAll(() async {
    // Initialize SharedPreferences with empty values
    SharedPreferences.setMockInitialValues({});
    prefs = await SharedPreferences.getInstance();

    // Create in-memory database for testing
    testDb = AppDatabase(NativeDatabase.memory());
    DatabaseService.instance.setTestDatabase(testDb);

    // Seed with test data - prefer UDDF import for consistent data
    bool uddfImported = false;
    if (_kUddfTestDataPath.isNotEmpty &&
        File(_kUddfTestDataPath).existsSync()) {
      // Use UDDF test data generated by Python script for consistent screenshots
      // ignore: avoid_print
      print('Loading test data from UDDF: $_kUddfTestDataPath');

      // Create repositories - they use DatabaseService.instance.database which
      // is now our test database
      final importer = UddfScreenshotImporter(
        diverRepository: DiverRepository(),
        diveRepository: DiveRepository(),
        siteRepository: SiteRepository(),
        buddyRepository: BuddyRepository(),
        equipmentRepository: EquipmentRepository(),
        equipmentSetRepository: EquipmentSetRepository(),
        tripRepository: TripRepository(),
        diveCenterRepository: DiveCenterRepository(),
        certificationRepository: CertificationRepository(),
        tagRepository: TagRepository(),
        diveTypeRepository: DiveTypeRepository(),
        tankPressureRepository: TankPressureRepository(),
      );
      try {
        await importer.importFromFile(_kUddfTestDataPath);
        uddfImported = true;
      } catch (e) {
        // macOS sandbox may block file access even if existsSync() passes.
        // Fall through to manual seeder below.
        // ignore: avoid_print
        print('UDDF import failed ($e), falling back to manual test data');
      }
    }
    if (!uddfImported) {
      // Fallback to manual seeder if UDDF file not available or import failed
      // ignore: avoid_print
      print('Using manual test data seeder');
      final seeder = ScreenshotTestDataSeeder(testDb);
      await seeder.seedAll();
    }

    // Initialize screenshot helper
    // Device name and output dir are passed via --dart-define from capture script
    screenshotHelper = ScreenshotHelper(binding: binding);
  });

  tearDownAll(() async {
    await testDb.close();
    DatabaseService.instance.resetForTesting();
  });

  group('App Store Screenshots', () {
    testWidgets('Capture all screens', (WidgetTester tester) async {
      // Set device orientation based on --dart-define value
      // iPad screenshots are taken in landscape, iPhone in portrait
      if (_kOrientation == 'landscape') {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.landscapeLeft,
          DeviceOrientation.landscapeRight,
        ]);
      } else {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.portraitUp,
          DeviceOrientation.portraitDown,
        ]);
      }
      await _settle(tester);

      // Launch the app with proper provider overrides
      await tester.pumpWidget(
        ProviderScope(
          overrides: [sharedPreferencesProvider.overrideWithValue(prefs)],
          child: const SubmersionApp(),
        ),
      );

      // Wait for initial load - app starts on /dashboard
      await _settle(tester, frames: 50);
      await screenshotHelper.waitForContent(tester);

      // 1. Dashboard (initial screen)
      await screenshotHelper.takeScreenshot(tester, 'dashboard');

      // 2. Navigate to Dives
      await _navigateTo(tester, Icons.scuba_diving_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'dive_list');

      // 3. Dive Detail - tap on a dive card
      // Use DiveListTile widget type to specifically target dive log entries,
      // avoiding other Cards in the UI (like summary cards in the detail pane).
      final random = Random();

      // Find all DiveListTile widgets - these are specifically the dive log entries
      final diveListTiles = find.byType(DiveListTile);

      // ignore: avoid_print
      print('Found ${diveListTiles.evaluate().length} DiveListTile widgets');

      if (diveListTiles.evaluate().length > 2) {
        // Pick a random dive tile from the visible ones (avoid items that may be off-screen)
        // On landscape iPad, fewer items are visible, so limit to first 5 items
        final maxIndex = min(diveListTiles.evaluate().length - 1, 4);
        final randomIndex = 1 + random.nextInt(max(1, maxIndex));
        // ignore: avoid_print
        print(
          'Selecting DiveListTile at index $randomIndex of ${diveListTiles.evaluate().length}',
        );

        // First ensure the item is visible by scrolling to it
        await tester.ensureVisible(diveListTiles.at(randomIndex));
        await _settle(tester);

        await tester.tap(diveListTiles.at(randomIndex));
        await _settle(tester);
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );

        // Verify we're on a dive detail page by looking for dive-specific content.
        // The detail pane should now show dive profile toggles or depth info.
        final pressureToggle = find.text('Pressure');
        final depthLabel = find.textContaining('Max Depth');

        // Check for dive-specific elements (profile chart toggles or depth info)
        final hasDiveContent =
            pressureToggle.evaluate().isNotEmpty ||
            depthLabel.evaluate().isNotEmpty;

        if (hasDiveContent) {
          // Enable Pressure and SAC toggles in the dive profile chart
          await _enableProfileToggles(tester);
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'dive_detail');
        } else {
          // Selection may not have worked - log warning
          // ignore: avoid_print
          print(
            'WARNING: Did not find dive content after tap, detail pane may not have updated',
          );
          // Still take a screenshot to see what's shown
          await screenshotHelper.takeScreenshot(tester, 'dive_detail');
        }

        // Go back to dive list (on mobile) or clear selection (on tablet)
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton.first);
          await _settle(tester);
        }
      }

      // 4. Navigate to Sites
      await _navigateTo(tester, Icons.location_on_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'sites_list');

      // 5. Sites Map view - find the map button and invoke it directly
      // On iPad, the compact app bar's IconButton may have hit-testing issues
      // due to overlapping gesture detectors, so we invoke the callback directly
      bool navigatedToMap = false;

      // Find IconButtons with the map icon - more direct than finding by tooltip
      final mapIconButtons = find.ancestor(
        of: find.byIcon(Icons.map),
        matching: find.byType(IconButton),
      );
      // ignore: avoid_print
      print('Found ${mapIconButtons.evaluate().length} map IconButtons');

      if (mapIconButtons.evaluate().isNotEmpty) {
        // Find a map button in the app bar area (y < 100)
        IconButton? targetButton;
        for (int i = 0; i < mapIconButtons.evaluate().length; i++) {
          final element = mapIconButtons.evaluate().toList()[i];
          final renderBox = element.renderObject as RenderBox?;
          if (renderBox != null) {
            final position = renderBox.localToGlobal(Offset.zero);
            // ignore: avoid_print
            print('Map IconButton $i at position: $position');

            if (position.dy < 100) {
              targetButton = element.widget as IconButton;
              // ignore: avoid_print
              print('Selected map IconButton at index $i');
              break;
            }
          }
        }

        // Fallback to first button if none found in app bar area
        targetButton ??= mapIconButtons.evaluate().first.widget as IconButton;

        // Invoke the button's onPressed callback directly
        // This bypasses hit-testing issues with overlapping gesture detectors
        if (targetButton.onPressed != null) {
          // ignore: avoid_print
          print('Invoking map button onPressed callback directly');
          targetButton.onPressed!();
          await _settle(tester);
        }

        // Wait for navigation
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );

        // Verify we're on the map page by looking for map-specific elements
        final listViewButton = find.byTooltip('List View');
        final flutterMap = find.byType(FlutterMap);

        navigatedToMap =
            listViewButton.evaluate().isNotEmpty ||
            flutterMap.evaluate().isNotEmpty;

        // ignore: avoid_print
        print('Navigation to map successful: $navigatedToMap');
      }

      if (navigatedToMap) {
        // Tap "Fit All Sites" button to center the map on all dive site markers
        final fitAllSitesButton = find.byTooltip('Fit All Sites');
        if (fitAllSitesButton.evaluate().isNotEmpty) {
          await tester.tap(fitAllSitesButton.first);
          await _settle(tester);
        } else {
          // Try finding by icon as fallback
          final myLocationIcon = find.byIcon(Icons.my_location);
          if (myLocationIcon.evaluate().isNotEmpty) {
            await tester.tap(myLocationIcon.first);
            await _settle(tester);
          }
        }

        // Wait longer for map tiles and markers to render
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 3),
        );

        // Find markers - could be individual (Icons.scuba_diving) or clustered
        // Clustered markers show a number in a circle, not an icon
        final individualMarkers = find.byIcon(Icons.scuba_diving);
        // ignore: avoid_print
        print(
          'Found ${individualMarkers.evaluate().length} individual scuba_diving markers',
        );

        if (individualMarkers.evaluate().isNotEmpty) {
          // Tap the first visible marker to select it and zoom in
          await tester.tap(individualMarkers.first);
          await _settle(tester);

          // Wait for map to animate to the selected site
          await screenshotHelper.waitForContent(
            tester,
            duration: const Duration(seconds: 2),
          );
        } else {
          // Markers are clustered - find clusters and tap to zoom in
          // Clusters are rendered as circular containers with a number (count) text
          // ignore: avoid_print
          print(
            'No individual markers found - markers are clustered, zooming in...',
          );

          // Try tapping clusters up to 3 times to zoom in enough to see individual markers
          for (int attempt = 0; attempt < 3; attempt++) {
            // Find cluster markers - they contain just a number in text
            // Look for Text widgets that contain only digits (cluster counts)
            final allText = find.byType(Text);
            Finder? clusterFinder;

            for (final element in allText.evaluate()) {
              final textWidget = element.widget as Text;
              final textData = textWidget.data;
              if (textData != null &&
                  textData.isNotEmpty &&
                  int.tryParse(textData) != null &&
                  int.parse(textData) > 1 &&
                  int.parse(textData) < 100) {
                // This looks like a cluster count
                clusterFinder = find.byWidget(textWidget);
                break;
              }
            }

            if (clusterFinder != null && clusterFinder.evaluate().isNotEmpty) {
              // ignore: avoid_print
              print(
                'Found cluster marker, tapping to zoom in (attempt ${attempt + 1})',
              );
              await tester.tap(clusterFinder.first);
              await _settle(tester);
              await screenshotHelper.waitForContent(
                tester,
                duration: const Duration(seconds: 2),
              );

              // Check if individual markers are now visible
              final markersAfterZoom = find.byIcon(Icons.scuba_diving);
              if (markersAfterZoom.evaluate().isNotEmpty) {
                // ignore: avoid_print
                print(
                  'Found ${markersAfterZoom.evaluate().length} individual markers after zoom',
                );
                // Tap a marker to select it
                await tester.tap(markersAfterZoom.first);
                await _settle(tester);
                await screenshotHelper.waitForContent(
                  tester,
                  duration: const Duration(seconds: 1),
                );
                break;
              }
            } else {
              // ignore: avoid_print
              print('No cluster markers found on attempt ${attempt + 1}');
              break;
            }
          }
        }

        // Wait for map tiles to render after any zoom/pan animation
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );
        await screenshotHelper.takeScreenshot(tester, 'sites_map');

        // Navigate back to sites list for next steps
        final listButton = find.byTooltip('List View');
        if (listButton.evaluate().isNotEmpty) {
          await tester.tap(listButton.first);
          await _settle(tester);
        } else {
          final backButton = find.byTooltip('Back');
          if (backButton.evaluate().isNotEmpty) {
            await tester.tap(backButton.first);
            await _settle(tester);
          }
        }
      } else {
        // ignore: avoid_print
        print('WARNING: Could not navigate to map view');
      }

      // 6. Navigate to Equipment
      if (_isDesktop) {
        // Desktop: Equipment is directly in NavigationRail
        await _navigateTo(tester, Icons.backpack_outlined);
        await screenshotHelper.waitForContent(tester);
        await _selectEquipmentCard(tester, screenshotHelper);
        await screenshotHelper.takeScreenshot(tester, 'equipment');
      } else {
        // Mobile: Equipment is under "More" menu
        await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
        await _settle(tester);
        final equipmentText = find.text('Equipment');
        if (equipmentText.evaluate().isNotEmpty) {
          await tester.tap(equipmentText.first);
          await _settle(tester);
          await screenshotHelper.waitForContent(tester);
          await _selectEquipmentCard(tester, screenshotHelper);
          await screenshotHelper.takeScreenshot(tester, 'equipment');
        }
      }

      // 7. Navigate to Statistics
      if (_isDesktop) {
        await _navigateTo(tester, Icons.bar_chart_outlined);
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        );
        await screenshotHelper.takeScreenshot(tester, 'statistics');
      } else {
        await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
        await _settle(tester);
        final statisticsText = find.text('Statistics');
        if (statisticsText.evaluate().isNotEmpty) {
          await tester.tap(statisticsText.first);
          await _settle(tester);
          await screenshotHelper.waitForContent(
            tester,
            duration: const Duration(seconds: 2),
          );
          await screenshotHelper.takeScreenshot(tester, 'statistics');
        }
      }

      // 8. Records
      final recordsText = find.text('Records');
      if (recordsText.evaluate().isNotEmpty) {
        await tester.tap(recordsText.first);
        await _settle(tester);
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'records');
      } else if (!_isDesktop) {
        // Mobile only: try via More menu
        await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
        await _settle(tester);
        final recordsInMore = find.text('Records');
        if (recordsInMore.evaluate().isNotEmpty) {
          await tester.tap(recordsInMore.first);
          await _settle(tester);
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'records');
        }
      }
    });
  });
}

/// Selects an equipment card in the list to show its detail pane.
Future<void> _selectEquipmentCard(
  WidgetTester tester,
  ScreenshotHelper screenshotHelper,
) async {
  final equipmentListView = find.byType(ListView);
  if (equipmentListView.evaluate().isNotEmpty) {
    final equipmentCards = find.descendant(
      of: equipmentListView.first,
      matching: find.byType(Card),
    );
    if (equipmentCards.evaluate().length > 1) {
      final cardIndex = min(2, equipmentCards.evaluate().length - 1);
      await tester.tap(equipmentCards.at(cardIndex));
      await _settle(tester);
      await screenshotHelper.waitForContent(
        tester,
        duration: const Duration(seconds: 1),
      );
    }
  }
}

/// Enables Pressure and SAC toggles in the dive profile chart.
/// These toggles show additional data curves on the profile graph.
Future<void> _enableProfileToggles(WidgetTester tester) async {
  // The toggles are text labels that can be tapped
  // Look for Pressure toggle and tap it if found
  final pressureToggle = find.text('Pressure');
  if (pressureToggle.evaluate().isNotEmpty) {
    await tester.tap(pressureToggle.first);
    await _settle(tester);
  }

  // Look for SAC toggle and tap it if found
  final sacToggle = find.text('SAC');
  if (sacToggle.evaluate().isNotEmpty) {
    await tester.tap(sacToggle.first);
    await _settle(tester);
  }
}

/// Taps a bottom navigation item by its icon.
/// Uses position filtering to ensure we tap the icon in the bottom navigation
/// area, not icons with the same IconData elsewhere (e.g., app bar menus).
Future<void> _tapBottomNavItem(WidgetTester tester, IconData icon) async {
  // Get the screen height to identify bottom navigation area
  final screenSize = tester.view.physicalSize / tester.view.devicePixelRatio;
  final bottomNavThreshold =
      screenSize.height * 0.8; // Bottom 20% is likely nav bar

  // Try to find the icon in the bottom navigation area
  final iconFinder = find.byIcon(icon);
  Widget? targetIcon = _findIconInBottomNav(iconFinder, bottomNavThreshold);

  // If not found, try the selected version of the icon
  if (targetIcon == null) {
    final selectedIcon = _getSelectedIcon(icon);
    if (selectedIcon != null) {
      final selectedIconFinder = find.byIcon(selectedIcon);
      targetIcon = _findIconInBottomNav(selectedIconFinder, bottomNavThreshold);
    }
  }

  if (targetIcon != null) {
    await tester.tap(find.byWidget(targetIcon), warnIfMissed: false);
    await _settle(tester);
  } else {
    // Fallback: tap first icon found (original behavior)
    if (iconFinder.evaluate().isNotEmpty) {
      await tester.tap(iconFinder.first, warnIfMissed: false);
      await _settle(tester);
    }
  }
}

/// Finds an icon widget that is positioned in the bottom navigation area.
Widget? _findIconInBottomNav(Finder finder, double bottomNavThreshold) {
  for (final element in finder.evaluate()) {
    final renderBox = element.renderObject as RenderBox?;
    if (renderBox != null && renderBox.hasSize) {
      final position = renderBox.localToGlobal(Offset.zero);
      // Check if the icon is in the bottom portion of the screen
      if (position.dy >= bottomNavThreshold) {
        return element.widget;
      }
    }
  }
  return null;
}

/// Gets the selected variant of an outlined icon.
IconData? _getSelectedIcon(IconData outlinedIcon) {
  if (outlinedIcon == Icons.home_outlined) return Icons.home;
  if (outlinedIcon == Icons.scuba_diving_outlined) return Icons.scuba_diving;
  if (outlinedIcon == Icons.location_on_outlined) return Icons.location_on;
  if (outlinedIcon == Icons.flight_outlined) return Icons.flight;
  if (outlinedIcon == Icons.more_horiz_outlined) return Icons.more_horiz;
  if (outlinedIcon == Icons.backpack_outlined) return Icons.backpack;
  if (outlinedIcon == Icons.people_outlined) return Icons.people;
  if (outlinedIcon == Icons.store_outlined) return Icons.store;
  if (outlinedIcon == Icons.bar_chart_outlined) return Icons.bar_chart;
  if (outlinedIcon == Icons.settings_outlined) return Icons.settings;
  return null;
}

/// Taps a NavigationRail item by its icon on desktop layout.
/// Uses position filtering to ensure we tap icons on the left edge (rail area),
/// not icons elsewhere in the UI.
Future<void> _tapNavRailItem(WidgetTester tester, IconData icon) async {
  const railMaxX = 200.0;

  final iconFinder = find.byIcon(icon);
  Widget? targetIcon = _findIconInNavRail(iconFinder, railMaxX);

  if (targetIcon == null) {
    final selectedIcon = _getSelectedIcon(icon);
    if (selectedIcon != null) {
      final selectedFinder = find.byIcon(selectedIcon);
      targetIcon = _findIconInNavRail(selectedFinder, railMaxX);
    }
  }

  if (targetIcon != null) {
    await tester.tap(find.byWidget(targetIcon), warnIfMissed: false);
    await _settle(tester);
  } else if (iconFinder.evaluate().isNotEmpty) {
    await tester.tap(iconFinder.first, warnIfMissed: false);
    await _settle(tester);
  }
}

/// Finds an icon widget positioned in the NavigationRail area (left edge).
Widget? _findIconInNavRail(Finder finder, double railMaxX) {
  for (final element in finder.evaluate()) {
    final renderBox = element.renderObject as RenderBox?;
    if (renderBox != null && renderBox.hasSize) {
      final position = renderBox.localToGlobal(Offset.zero);
      if (position.dx <= railMaxX) {
        return element.widget;
      }
    }
  }
  return null;
}

/// Navigates to a screen using the appropriate navigation method.
/// On desktop: taps NavigationRail icon directly.
/// On mobile: taps BottomNavigationBar icon.
Future<void> _navigateTo(WidgetTester tester, IconData icon) async {
  if (_isDesktop) {
    await _tapNavRailItem(tester, icon);
  } else {
    await _tapBottomNavItem(tester, icon);
  }
}
