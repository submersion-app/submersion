/// App Store Screenshot Automation Tests
///
/// This integration test captures screenshots of key app screens for
/// App Store submission. Run via the capture script:
///
/// ```bash
/// ./scripts/capture_screenshots.sh
/// # Or via fastlane:
/// cd ios && bundle exec fastlane screenshots
/// ```
///
/// Screenshots are saved to `screenshots/{device_name}/` directory.
/// The output path, device name, and UDDF test data path are passed via --dart-define.
library;

import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:submersion/app.dart';
import 'package:submersion/core/database/database.dart';
import 'package:submersion/core/providers/provider.dart';
import 'package:submersion/core/services/database_service.dart';
import 'package:submersion/features/buddies/data/repositories/buddy_repository.dart';
import 'package:submersion/features/certifications/data/repositories/certification_repository.dart';
import 'package:submersion/features/dive_centers/data/repositories/dive_center_repository.dart';
import 'package:submersion/features/dive_log/data/repositories/dive_repository_impl.dart';
import 'package:submersion/features/dive_log/data/repositories/tank_pressure_repository.dart';
import 'package:submersion/features/dive_sites/data/repositories/site_repository_impl.dart';
import 'package:submersion/features/dive_types/data/repositories/dive_type_repository.dart';
import 'package:submersion/features/divers/data/repositories/diver_repository.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_repository_impl.dart';
import 'package:submersion/features/equipment/data/repositories/equipment_set_repository_impl.dart';
import 'package:submersion/features/settings/presentation/providers/settings_providers.dart';
import 'package:submersion/features/tags/data/repositories/tag_repository.dart';
import 'package:submersion/features/trips/data/repositories/trip_repository.dart';
import 'package:drift/native.dart';

import 'helpers/screenshot_helper.dart';
import 'helpers/screenshot_test_data.dart';
import 'helpers/uddf_screenshot_helper.dart';

/// Path to UDDF test data file, passed via --dart-define from capture script.
const String _kUddfTestDataPath = String.fromEnvironment(
  'UDDF_TEST_DATA_PATH',
  defaultValue: '',
);

/// Device orientation, passed via --dart-define from capture script.
/// Values: 'portrait' or 'landscape'
const String _kOrientation = String.fromEnvironment(
  'SCREENSHOT_ORIENTATION',
  defaultValue: 'portrait',
);

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  late AppDatabase testDb;
  late ScreenshotHelper screenshotHelper;
  late SharedPreferences prefs;

  setUpAll(() async {
    // Initialize SharedPreferences with empty values
    SharedPreferences.setMockInitialValues({});
    prefs = await SharedPreferences.getInstance();

    // Create in-memory database for testing
    testDb = AppDatabase(NativeDatabase.memory());
    DatabaseService.instance.setTestDatabase(testDb);

    // Seed with test data - prefer UDDF import for consistent data
    if (_kUddfTestDataPath.isNotEmpty &&
        File(_kUddfTestDataPath).existsSync()) {
      // Use UDDF test data generated by Python script for consistent screenshots
      // ignore: avoid_print
      print('Loading test data from UDDF: $_kUddfTestDataPath');

      // Create repositories - they use DatabaseService.instance.database which
      // is now our test database
      final importer = UddfScreenshotImporter(
        diverRepository: DiverRepository(),
        diveRepository: DiveRepository(),
        siteRepository: SiteRepository(),
        buddyRepository: BuddyRepository(),
        equipmentRepository: EquipmentRepository(),
        equipmentSetRepository: EquipmentSetRepository(),
        tripRepository: TripRepository(),
        diveCenterRepository: DiveCenterRepository(),
        certificationRepository: CertificationRepository(),
        tagRepository: TagRepository(),
        diveTypeRepository: DiveTypeRepository(),
        tankPressureRepository: TankPressureRepository(),
      );
      await importer.importFromFile(_kUddfTestDataPath);
    } else {
      // Fallback to manual seeder if UDDF file not available
      // ignore: avoid_print
      print('UDDF file not found, using manual test data seeder');
      final seeder = ScreenshotTestDataSeeder(testDb);
      await seeder.seedAll();
    }

    // Initialize screenshot helper
    // Device name and output dir are passed via --dart-define from capture script
    screenshotHelper = ScreenshotHelper(binding: binding);
  });

  tearDownAll(() async {
    await testDb.close();
    DatabaseService.instance.resetForTesting();
  });

  group('App Store Screenshots', () {
    testWidgets('Capture all screens', (WidgetTester tester) async {
      // Set device orientation based on --dart-define value
      // iPad screenshots are taken in landscape, iPhone in portrait
      if (_kOrientation == 'landscape') {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.landscapeLeft,
          DeviceOrientation.landscapeRight,
        ]);
      } else {
        await SystemChrome.setPreferredOrientations([
          DeviceOrientation.portraitUp,
          DeviceOrientation.portraitDown,
        ]);
      }
      await tester.pumpAndSettle();

      // Launch the app with proper provider overrides
      await tester.pumpWidget(
        ProviderScope(
          overrides: [sharedPreferencesProvider.overrideWithValue(prefs)],
          child: const SubmersionApp(),
        ),
      );

      // Wait for initial load - app starts on /dashboard
      await tester.pumpAndSettle(const Duration(seconds: 3));
      await screenshotHelper.waitForContent(tester);

      // 1. Dashboard (initial screen)
      await screenshotHelper.takeScreenshot(tester, 'dashboard');

      // 2. Navigate to Dives - tap on scuba diving icon in bottom nav
      await _tapBottomNavItem(tester, Icons.scuba_diving_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'dive_list');

      // 3. Dive Detail - tap on a random dive card for variety in screenshots
      final listTiles = find.byType(ListTile);
      final cards = find.byType(Card);
      final random = Random();

      // Try to find and tap a dive item (pick random one for visual variety)
      if (listTiles.evaluate().length > 2) {
        // Pick a random index, skipping index 0 (may be header)
        final maxIndex = listTiles.evaluate().length - 1;
        final randomIndex = 1 + random.nextInt(maxIndex); // Range: 1 to maxIndex
        // ignore: avoid_print
        print('Selecting dive at index $randomIndex of ${listTiles.evaluate().length} items');

        await tester.tap(listTiles.at(randomIndex));
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);

        // Enable Pressure and SAC toggles in the dive profile chart
        await _enableProfileToggles(tester);
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'dive_detail');

        // Go back to dive list
        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton.first);
          await tester.pumpAndSettle();
        }
      } else if (cards.evaluate().length > 1) {
        // Pick a random card, skipping index 0 (may be header)
        final maxIndex = cards.evaluate().length - 1;
        final randomIndex = 1 + random.nextInt(maxIndex); // Range: 1 to maxIndex
        // ignore: avoid_print
        print('Selecting dive card at index $randomIndex of ${cards.evaluate().length} cards');

        await tester.tap(cards.at(randomIndex));
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);

        // Enable Pressure and SAC toggles in the dive profile chart
        await _enableProfileToggles(tester);
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'dive_detail');

        final backButton = find.byTooltip('Back');
        if (backButton.evaluate().isNotEmpty) {
          await tester.tap(backButton.first);
          await tester.pumpAndSettle();
        }
      }

      // 4. Navigate to Sites
      await _tapBottomNavItem(tester, Icons.location_on_outlined);
      await screenshotHelper.waitForContent(tester);
      await screenshotHelper.takeScreenshot(tester, 'sites_list');

      // 5. Sites Map view - look for map icon button in app bar
      final mapButton = find.byIcon(Icons.map);
      final mapOutlinedButton = find.byIcon(Icons.map_outlined);
      if (mapButton.evaluate().isNotEmpty) {
        await tester.tap(mapButton.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 3),
        ); // Map tiles need time
        await screenshotHelper.takeScreenshot(tester, 'sites_map');
      } else if (mapOutlinedButton.evaluate().isNotEmpty) {
        await tester.tap(mapOutlinedButton.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 3),
        );
        await screenshotHelper.takeScreenshot(tester, 'sites_map');
      }

      // 6. Navigate to Equipment via "More" menu
      await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
      await tester.pumpAndSettle();

      // Find and tap Equipment in the menu/list
      final equipmentText = find.text('Equipment');
      if (equipmentText.evaluate().isNotEmpty) {
        await tester.tap(equipmentText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'equipment');
      }

      // 7. Navigate to Statistics via "More" menu
      await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
      await tester.pumpAndSettle();

      final statisticsText = find.text('Statistics');
      if (statisticsText.evaluate().isNotEmpty) {
        await tester.tap(statisticsText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(
          tester,
          duration: const Duration(seconds: 2),
        ); // Charts need time
        await screenshotHelper.takeScreenshot(tester, 'statistics');
      }

      // 8. Navigate to Records
      // First check if Records is directly accessible or under Statistics
      final recordsText = find.text('Records');
      if (recordsText.evaluate().isNotEmpty) {
        await tester.tap(recordsText.first);
        await tester.pumpAndSettle();
        await screenshotHelper.waitForContent(tester);
        await screenshotHelper.takeScreenshot(tester, 'records');
      } else {
        // Try via More menu
        await _tapBottomNavItem(tester, Icons.more_horiz_outlined);
        await tester.pumpAndSettle();
        final recordsInMore = find.text('Records');
        if (recordsInMore.evaluate().isNotEmpty) {
          await tester.tap(recordsInMore.first);
          await tester.pumpAndSettle();
          await screenshotHelper.waitForContent(tester);
          await screenshotHelper.takeScreenshot(tester, 'records');
        }
      }
    });
  });
}

/// Enables Pressure and SAC toggles in the dive profile chart.
/// These toggles show additional data curves on the profile graph.
Future<void> _enableProfileToggles(WidgetTester tester) async {
  // The toggles are text labels that can be tapped
  // Look for Pressure toggle and tap it if found
  final pressureToggle = find.text('Pressure');
  if (pressureToggle.evaluate().isNotEmpty) {
    await tester.tap(pressureToggle.first);
    await tester.pumpAndSettle();
  }

  // Look for SAC toggle and tap it if found
  final sacToggle = find.text('SAC');
  if (sacToggle.evaluate().isNotEmpty) {
    await tester.tap(sacToggle.first);
    await tester.pumpAndSettle();
  }
}

/// Taps a bottom navigation item by its icon.
Future<void> _tapBottomNavItem(WidgetTester tester, IconData icon) async {
  // Try to find the icon in the bottom navigation
  final iconFinder = find.byIcon(icon);
  if (iconFinder.evaluate().isNotEmpty) {
    await tester.tap(iconFinder.first);
    await tester.pumpAndSettle();
  } else {
    // Try the selected version of the icon (some icons change when selected)
    final selectedIcon = _getSelectedIcon(icon);
    if (selectedIcon != null) {
      final selectedIconFinder = find.byIcon(selectedIcon);
      if (selectedIconFinder.evaluate().isNotEmpty) {
        await tester.tap(selectedIconFinder.first);
        await tester.pumpAndSettle();
      }
    }
  }
}

/// Gets the selected variant of an outlined icon.
IconData? _getSelectedIcon(IconData outlinedIcon) {
  if (outlinedIcon == Icons.home_outlined) return Icons.home;
  if (outlinedIcon == Icons.scuba_diving_outlined) return Icons.scuba_diving;
  if (outlinedIcon == Icons.location_on_outlined) return Icons.location_on;
  if (outlinedIcon == Icons.flight_outlined) return Icons.flight;
  if (outlinedIcon == Icons.more_horiz_outlined) return Icons.more_horiz;
  return null;
}
