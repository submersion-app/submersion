#!/usr/bin/env python3
"""
Generate ocean_tide.yaml configuration file for PyFES.

AVISO distributes FES2022/FES2014 NetCDF files but not the YAML config
that PyFES needs. This script scans a directory of FES NetCDF files
and generates the appropriate configuration.

Usage:
    python generate_fes_config.py /path/to/fes2022/ocean_tide_extrapolated

This will create ocean_tide.yaml in the same directory.
"""

import argparse
import sys
from pathlib import Path

# FES constituent file patterns
# Maps the expected NetCDF filename (lowercase) to the PyFES constituent name
FES_CONSTITUENTS = {
    '2n2': '2N2',
    'eps2': 'Eps2',
    'j1': 'J1',
    'k1': 'K1',
    'k2': 'K2',
    'l2': 'L2',
    'la2': 'Lambda2',  # PyFES uses full name
    'lambda2': 'Lambda2',
    'm2': 'M2',
    'm3': 'M3',
    'm4': 'M4',
    'm6': 'M6',
    'm8': 'M8',
    'mf': 'Mf',
    'mks2': 'MKS2',
    'mm': 'Mm',
    'mn4': 'MN4',
    'ms4': 'MS4',
    'msf': 'Msf',
    'msqm': 'Msqm',
    'mtm': 'Mtm',
    'mu2': 'Mu2',
    'n2': 'N2',
    'n4': 'N4',
    'nu2': 'Nu2',
    'o1': 'O1',
    'oo1': 'OO1',
    'p1': 'P1',
    'q1': 'Q1',
    'r2': 'R2',
    's1': 'S1',
    's2': 'S2',
    's4': 'S4',
    'sa': 'Sa',
    'ssa': 'Ssa',
    't2': 'T2',
    '2q1': '2Q1',
    'sig1': 'Sigma1',  # PyFES uses full name
    'sigma1': 'Sigma1',
    'rho1': 'Rho1',
    'm1': 'M1',
    'chi1': 'Chi1',
    'pi1': 'Pi1',
    'phi1': 'Phi1',
    'the1': 'Theta1',  # PyFES uses full name
    'theta1': 'Theta1',
}


def find_nc_files(directory: Path) -> dict:
    """Find all NetCDF files and map to constituent names.

    Handles multiple naming conventions:
    - m2.nc (FES2014 style)
    - m2_fes2022.nc (FES2022 style)
    - m2_ocean_extrapolated.nc (alternative style)

    Returns:
        Dict mapping PyFES constituent name -> relative file path
    """
    constituents = {}

    for nc_file in directory.glob('*.nc'):
        # Get the base name without extension (lowercase for matching)
        base_name = nc_file.stem.lower()

        # Strip common suffixes to get the constituent name
        # e.g., "m2_fes2022" -> "m2", "s2_ocean_extrapolated" -> "s2"
        for suffix in ['_fes2022', '_fes2014', '_ocean_extrapolated', '_extrapolated']:
            if base_name.endswith(suffix):
                base_name = base_name[:-len(suffix)]
                break

        # Try to match to a known constituent
        if base_name in FES_CONSTITUENTS:
            const_name = FES_CONSTITUENTS[base_name]
            constituents[const_name] = nc_file.name
        else:
            print(f"  Warning: Unknown constituent file: {nc_file.name} (parsed as '{base_name}')")

    return constituents


def generate_yaml(constituents: dict, directory: Path, output_path: Path) -> None:
    """Generate PyFES YAML configuration file.

    PyFES expects a specific YAML structure with grid type (cartesian or lgp).
    FES2014/FES2022 use cartesian grids.

    Args:
        constituents: Dict of constituent name -> filename
        directory: Directory containing NetCDF files (for absolute paths)
        output_path: Where to write the YAML file
    """
    # Build YAML content with correct PyFES structure
    # FES models use cartesian grids
    lines = [
        "# PyFES configuration for FES ocean tide model",
        "# Auto-generated by generate_fes_config.py",
        "#",
        "# Grid type: cartesian (regular lat/lon grid)",
        "# See: https://github.com/CNES/aviso-fes",
        "",
        "tide:",
        "  cartesian:",
        "    paths:",
    ]

    # Sort constituents for consistent output
    for const_name in sorted(constituents.keys()):
        filename = constituents[const_name]
        # Use absolute path
        abs_path = directory / filename
        lines.append(f"      {const_name}: {abs_path}")

    yaml_content = '\n'.join(lines) + '\n'

    with open(output_path, 'w') as f:
        f.write(yaml_content)

    print(f"\nGenerated: {output_path}")
    print(f"Constituents: {len(constituents)}")


def main():
    parser = argparse.ArgumentParser(
        description='Generate ocean_tide.yaml for PyFES from FES NetCDF files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )

    parser.add_argument(
        'fes_directory',
        help='Directory containing FES NetCDF files (e.g., ocean_tide_extrapolated)',
    )

    parser.add_argument(
        '--output', '-o',
        help='Output YAML file path (default: ocean_tide.yaml in the FES directory)',
    )

    args = parser.parse_args()

    fes_dir = Path(args.fes_directory).resolve()

    if not fes_dir.exists():
        print(f"ERROR: Directory not found: {fes_dir}")
        sys.exit(1)

    if not fes_dir.is_dir():
        print(f"ERROR: Not a directory: {fes_dir}")
        sys.exit(1)

    print(f"Scanning: {fes_dir}")
    constituents = find_nc_files(fes_dir)

    if not constituents:
        print("ERROR: No NetCDF files found!")
        print("Expected files like: m2.nc, s2.nc, k1.nc, etc.")
        sys.exit(1)

    print(f"Found {len(constituents)} constituent files:")
    for name in sorted(constituents.keys())[:10]:
        print(f"  {name}: {constituents[name]}")
    if len(constituents) > 10:
        print(f"  ... and {len(constituents) - 10} more")

    # Determine output path
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = fes_dir / 'ocean_tide.yaml'

    generate_yaml(constituents, fes_dir, output_path)

    print("\nNext steps:")
    print(f"  1. Set FES_DATA to parent directory: export FES_DATA={fes_dir.parent}")
    print(f"  2. Or use --config: python extract_fes_constituents.py --config {output_path}")


if __name__ == '__main__':
    main()
